# -*- coding: utf-8 -*-
"""Malware Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10cXNsqmPM8Itc4J127I6FCiVQgPdYmHh

# Importing libraires
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split

"""# Exploring the malware dataset"""

malData=pd.read_csv(r"C:\Users\ashut\Desktop\Machine Learning\Input\MalwareData.csv.gz", sep="|", low_memory =True )

"""## Check for unique values and various types of values in the Detection Dataset
### We can note that the Name and md5 features are not really helping us in prediction if a given line is a malware or not. So, we can remove them
"""

malData.nunique(axis=0)

## Check for null values

null_values = malData.isnull().sum()

# Display columns with null values and their respective counts
print(null_values)

"""## Seeing how the data looks using head"""

print("Dataset for first five elements looks like: -\n")
print(malData.head())
print("\n\n The shape of the dataset is as: -")
print(malData.shape)
print("\n\n The dataset description looks like: -")
print(malData.describe())

"""## Looking at how balanced the dataset is based on target feature @Legitimate"""

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
ax.hist(malData['legitimate'],20)
plt.show()

"""## Data Cleaning and Train Test Set Creation"""

#Define target
dfY = malData['legitimate']

#Remove unwanted columns
malData=malData.drop(['Name'],axis=1)
malData=malData.drop(['md5'],axis=1)

#Define Descriptive Features
dfX = malData.drop(['legitimate'],axis=1)

#Based on experimentation and careful considerations below columns are choosen
cols = ['DllCharacteristics', 'Characteristics', 'Machine', 'VersionInformationSize', 'SectionsMaxEntropy', 'Subsystem', 'ImageBase', 'MajorSubsystemVersion', 'ResourcesMinEntropy', 'SizeOfOptionalHeader', 'ResourcesMaxEntropy', 'SectionsMinEntropy', 'MajorOperatingSystemVersion', 'SectionsMeanEntropy']
dfX = malData[cols]

#Split Dataset
X_train, X_test, Y_train, Y_test = train_test_split(dfX,dfY, test_size=0.2, random_state=42)

"""# Model Building </br> </br>
## 1- Random Forest
"""

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

random_forest = RandomForestClassifier(n_estimators=100, random_state=42)

# Fitting the model to the training data
random_forest.fit(X_train, Y_train)

# Making predictions on the test set
predictions = random_forest.predict(X_test)

# Evaluating the model
accuracy = accuracy_score(Y_test, predictions)
print(f"Accuracy: {accuracy}")

from sklearn.metrics import confusion_matrix
# Generating the confusion matrix
conf_matrix = confusion_matrix(Y_test, predictions)

# Displaying the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues",
            xticklabels=['Predicted Negative', 'Predicted Positive'],
            yticklabels=['Actual Negative', 'Actual Positive'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

"""## 2- KNN"""

from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

knn = KNeighborsClassifier(n_neighbors=5)  # For example, using 5 neighbors

# Fitting the model to the training data
knn.fit(X_train, Y_train)

# Making predictions on the test set
predictions = knn.predict(X_test)

# Evaluating the model
accuracy = accuracy_score(Y_test, predictions)
print(f"Accuracy: {accuracy}")

from sklearn.metrics import confusion_matrix
# Generating the confusion matrix
conf_matrix = confusion_matrix(Y_test, predictions)

# Displaying the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues",
            xticklabels=['Predicted Negative', 'Predicted Positive'],
            yticklabels=['Actual Negative', 'Actual Positive'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

"""## 3- Decision Tree"""

from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# Creating the Decision Tree model
decision_tree = DecisionTreeClassifier(random_state=42,max_depth=10)

# Fitting the model to the training data
decision_tree.fit(X_train, Y_train)

# Making predictions on the test set
predictions = decision_tree.predict(X_test)

# Evaluating the model
accuracy = accuracy_score(Y_test, predictions)
print(f"Accuracy: {accuracy}")

from sklearn.metrics import confusion_matrix
# Generating the confusion matrix
conf_matrix = confusion_matrix(Y_test, predictions)

# Displaying the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues",
            xticklabels=['Predicted Negative', 'Predicted Positive'],
            yticklabels=['Actual Negative', 'Actual Positive'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

"""## 4- Logistic Regression"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

logistic_regression = LogisticRegression(max_iter=1000, random_state=42)
#logistic_regression = LogisticRegression(random_state=42)

# Fitting the model to the training data
logistic_regression.fit(X_train, Y_train)

# Making predictions on the test set
predictions = logistic_regression.predict(X_test)

# Evaluating the model
accuracy = accuracy_score(Y_test, predictions)
print(f"Accuracy: {accuracy}")

from sklearn.metrics import confusion_matrix
# Generating the confusion matrix
conf_matrix = confusion_matrix(Y_test, predictions)

# Displaying the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues",
            xticklabels=['Predicted Negative', 'Predicted Positive'],
            yticklabels=['Actual Negative', 'Actual Positive'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

"""## 5- Neural Networks"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# Define model
model = Sequential()
model.add(Dense(16, input_dim=14, activation= "relu"))
model.add(Dense(8, activation= "relu"))
model.add(Dense(4, activation= "relu"))
model.add(Dense(1, activation='sigmoid'))
model.summary() #Print model Summary

# Compile model
model.compile(loss= "binary_crossentropy" , optimizer="rmsprop", metrics=["accuracy"])

# Fit Model
model.fit(X_train, Y_train, epochs=5, batch_size=32)

prediction = model.predict(X_test)
prediction = [1 if y>= 0.5 else 0   for y in prediction]

# Evaluating the model
accuracy = accuracy_score(Y_test, prediction)
print(f"Accuracy: {accuracy}")

from sklearn.metrics import confusion_matrix
# Generating the confusion matrix
conf_matrix = confusion_matrix(Y_test, prediction)

# Displaying the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues",
            xticklabels=['Predicted Negative', 'Predicted Positive'],
            yticklabels=['Actual Negative', 'Actual Positive'])
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.title('Confusion Matrix')
plt.show()

